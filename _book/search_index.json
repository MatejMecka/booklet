[["intro.html", "Препораки за репродуцибилно анализирање на податоци Chapter 1 Вовед 1.1 Аналогија 1.2 Организација", " Препораки за репродуцибилно анализирање на податоци Теофил Наков, Новица Наков 2020-12-13 Chapter 1 Вовед Овој текст е обид да се направи преглед и да се понудат препораки за безбедна пракса при ракување, анализирање и објавување на податоци. Под „безбедна пракса“ подразбираме чекори коишто доколку ги следиме ќе имаме некаква сигурност дека резултатот којшто го презентираме може да ги добие секој доколку ги користи истите податоци и следи истите процедури кои ги објавуваме заедно со резултатот. Се чини дека оваа поента е доволно очигледна и некој би рекол дека воопшто нема потреба да се зборува за ова. Сите се согласуваме со тоа дека кога некоја наша колешка ќе направи некаква анализа, ние, доколку имаме доволно информации за нејзината анализа, можеме да ја повториме и да ги добиеме истите резултати. Но во пракса оваа удобна идеја ретко кога се остварува. Наместо повторливост, кога се обидуваме да повториме некоја анализа вообичаено е да се соочиме со забуна и фрустрација. Ова често завршува со откажување или правење на анализата од почеток, односно, бесполезно и контрапродуктивно губење на време, ресурси и пари. Горната дефиниција на „безбедна пракса“ (без преправање дека ова е некаква прецизна дефиниција) повикува барем две дополнителни поенти за тоа што подразбира да анализираме податоци и да објавуваме резултати на начин што овозможува точно повторување. Имено, објавувањето на резултат мора да биде поддржано со објавување на 1) точните податоци коишто биле употребени да се направи анализата, и 2) деталната процедура којашто била извршена за да се добие резултатот. Подоцна ќе видиме зошто се неопходни овие компоненти (иако веруваме дека е горе-доле очигледно) и на кој начин е најдобро да се презентираат/објават. Тука е можеби полезно да направиме разлика помеѓу повторливоста која ја опишуваме до сега и еден друг тип на повторливост што има поголема фундаменталност и тежина. Во природните науки, кога зборуваме дека нешто е научна вистина или научно знаење, тоа скоро секогаш се однесува на резултати коишто се повторливи и коишто можат да се докажат од различни агли. Дали почнувајќи со различни податоци, или со поставување на нови експерименти, или со употреба на поинакви анализи, критично е да дојдеме до истиот резултат за тој да биде прифатен како една компонента од тоа како светот функционира (научна вистина). На пример, дека Земјата е сферична може да се докаже со податоци од циркумнавигација, со мерење на аголот на сончевите зраци на различни географски локации, со движењето на Фуковото нишало, со самото постоење на ГПС навигација, со фотографии од возила во орбитата, и така натаму. Значи истиот резултат можеме да го изведеме од многу различни податоци и методи. За разлика од ваквата репликација, фокусот на овој текст е поскромен, и се однесува на далеку полесниот концепт на повторување на истиот рецепт, со истите состојки, за да ја направиме истата пита. 1.1 Аналогија Проширување на горната аналогија е добар начин да се запознаеме со главните компоненти на повторливата обработка на податоци. Кога правиме пита имаме состојки (брашно, квасец, спанаќ, сирење), рецепт од неколку чекори (нарасни го квасецот, замеси тесто, засукај кори) и неопходни алатки (лонче, тарун, тепсија, фурна). Кога сакаме да ја направиме истата пита што ја прави бабата на нашиот пријател, треба да ги имаме сите состојки, информации за сите чекори за подготовка како и сите алатки. Ако имаме брашно, вода и сол ама сме заборавиле квасец, нема да може да замесиме тесто. Ако немаме сукало, ќе треба да тегнеме кори, што секако ќе значи поинаква пита. Значи, за да ја повториме питата потребно е да ги имаме сите неопходни елементи и инфмормации коишто ќе овозможат точно повторување на секој чекор. Затоа не е чудно што рецепти за готвење често доаѓаат со слики или видео. Тоа се медиуми побогати со информации и затоа поадекватни за пренесување комплексни процеси како правење пита. Без разлика од тоа колку детално некој опишал како се сука кора со радиус од 25 cm, со видео од процесот ние добиваме далеку подобро разбирање за процедурата. Во сферата на анализа за податоци, аналозите на горните компоненти се: податоците ~ состојки изворниот код ~ рецепт и софтверски пакети од коишто зависи нашиот код ~ алатки На пример, ако правиме анализа на невработеност низ Северна Македонија и имаме една табела со невработеност по општини но сме ги групирале податоците по градови користејќи друга табела, тогаш за точна репликација на нашата анализа треба да ги споделиме двете табели (и брашното и квасецот). Слично, за некој да ги направи истите графици за невработеност по град, треба да го споделиме и нашиот код за правење на анализата (рецептот), како и информации за софтверот во којшто сме го извршиле тој код (тарунот). Некогаш тарунот не е неопходен за да се направи истата пита, можеби само температурата на фурната е битна, и во ваквите случаи можеме да го споделиме рецептот без рестрикција за алатката што треба да се користи. Но во други случаи, дури и да се достапни точните податоци и документираниот изворен код, анализата не може да се повтори без некоја специјална алатка. Во овие случаи ние би требало да ги спакуваме и споделиме дури и нашите алатки. За среќа, аналогијата помеѓу правење пита и повторување на некоја анализа завршува со споделување на податоците, кодот, и информации за алатките. Имајќи пристап до овие компоненти, дури и никогаш да не сте правеле некаква специфична анализа во некој специфичен софтвер, вие сепак ќе можете да ги извршите истите документирани чекори и да дојдете до истиот резултат. Повторувањето на анализата не бара пракса, умешност, искуство и не зависи од тоа колку е влажно брашното. Ако креирањето повторливи документи или анализи ви звучеше како комплициран концепт, се надеваме дека со оваа аналогија станува јасно дека е далеку полесно од обидот да се направи пита како како бабата на пријателот или пица како од ресторан. 1.2 Организација Темата на овој текст е доволно опширна што тука нема ни да се обидеме да дадеме севкупен третмант на сите значајни аспекти. Туку, целта е да дадеме преглед на главните принципи за повторливи анализи и практични примери за главните препораки. ** NEEDS TO BE UPDATED BASED ON LATER CHAPTERS AND NEEDS TO LINK TO LATER CHAPTER** По воведот, прво ќе се запознаеме со софтверските алатки кои ќе ги користиме понатаму (Поглавје 2: Алатки), и ќе посочиме некои од најчестите случаи кога една анализа, дури и да имаме најдобри намери, може да биде “неповторлива“ (Поглавје 3: Не-повторливи анализи). Понатаму ќе ги разгледаме главните начини на кои постоечки код за некоја анализа која е тешка да се повтори може да се конвертира во повторлива анализа (Поглавје 4: Конверзија во повторлив код и Поглавје 5: Повтрливи проекти) и за пишување на документи коишто ги покажуваат нашите размислувањз, претпоставки, хипотези, заедно со кодот што го користиме за нивно тестирање и резултатите од тие тестови (Поглавје 5: Повторливи документи / извештаи (Rmd)). За крај, ќе зборуваме за контола на изворниот код со git што ни дава слобода и безбедност за променување и подобрување (Поглавје 6: Контрола на изворниот код) и за случаевите кога дури и се околу нашата анализа да е повторливо, некој едноставно не може да ја повтори нашата анализа бидејќи нема пристап до алатките коишто ние ги користиме (Поглавје 7: Што ако вашиот колега има Mac, или друга верзија на R? Docker.). Текстот го затвораме со заклучок и литература со препорака во најмала рака да ги погледнете ресурсите дадени во библиографијата бидејќи содржат далеку подетални и ефективни третмани на темата на повторливо ракување, анализирање и објавување на податоци. 1.2.1 Што беше планот: title: Препораки за повторливо ракување, анализирање, и објавување на податоци more realistic title: Препораки за повторливо анализирање на податоци done: c1: Вовед c2: Алатки c3: Типична анализа (која никој, дури ни авторот, не може да ја повтори) c4: Брза конверзија во повторлива анализа: Скрипта c4.5: повторливи проекти yet to do: c5: Повторливи документи / извештаи (Rmd) c6: Контрола на изворниот код (git / GitHub) c7: Што ако вашиот колега има Mac, или друга верзија на R? Docker. c8: Заклучок c9: Литература "],["tools.html", "Chapter 2 Алатки 2.1 Програмски јазик: R 2.2 Контрола на изворен код: git 2.3 Виртуелни контејнери: docker 2.4 Резиме", " Chapter 2 Алатки 2.1 Програмски јазик: R Генерално земено, во денешно време, доколку анализирате податоци тоа вероратно го правите со помош на Python (и пакети како: pandas, numpy, matplotlib) или R (со пакети како: dplyr (Wickham, François, et al. 2020), data.table (Dowle and Srinivasan 2019), ggplot2 (Wickham, Chang, et al. 2020)). Доколку работите на пониско ниво или вашата работа е поблиска до математика, можеби користите c# за забрзување на вашиот код, но генерално, ретко кога јазик од типот на c# сe користи за интерактивна анализа на податоци, графирање, или машинско учење. Конечно понови јазици, како Julia и Scala имаат дополнителни предности со тоа што овозможуваат полесно пишување код во експлоративни сесии како Python ili R но со брзина на компутација што е поблиска до c или c#. Во секој случај, препораките дадени во овој текст се апликабилни без разлика на програмскиот јазик што го користите. Во овој текст генерално ќе работиме со софтверски алатки од R екосистемот. R е програмски јазик пред се наменет кон статистички анализи, и иако не е најраспространет или најшироко користен, е од особено значење за анализа на податоци, и следствено повторлива анализа на податоци. Главните причини за употребата на R авторите на овој текст секојдневно користат R и Rstudio и поради тоа што има еден куп дополнителни екстензии во оваа средина кои овозможуваат лесно пишување на повторливи технички извештаи, научни трудови (Rmarkdown (Allaire et al. 2020)), книги (bookdown (Xie 2020b)), веб апликации (shiny (Chang et al. 2020)), блогови (blogdown (Xie 2020a)), итн. Самиот овој текст го пишувамe со помош на bookdown, што овозможува неверојатно лесно составање и објавивање на подолги текстови (книги) со поглавја, компјутерски код, и математичка нотација со едно копче во Rstudio. Во овој текст немаме намера да навлегуваме длабоко во самото кодирање во R. Нашиот приод ќе биде да објасниме одреден принцип со обични зборови и да покажеме како тоа би можело да изгледа со R код. Што значи, дури и да не знаете ништо за R би можеле да го следите текстот и да ги употребите препораките во вашиот омилен програмски јазик за обработка на податоци. Во некои делови ќе користиме материјали кои се специфични за R и Rstudio (на пример Rmarkdown) така што можеби ќе има технички детали кои нема да може да директно да ги примените во Jypiter тетратка или доколку работите во друг текст едитор (VScode). Но повторно, имајќи предвид дека препораките ќе тежнеат кон тоа како да пишуваме код којшто ќе бара минимална интервенција при (ре)анализа на податоци, ваквите аспекти специфични за Rstudio ќе бидат сведени на минимум. Генерално, целта ни е да креираме пакет (фолдер) за правење пита што вклучува се што е неопходно за нашиот пријател да може без многу мислење да ја направи истата пита. За да го олесниме овој процес, треба да се стремиме кон тоа да не користиме специјален тарун (софтвер) за да ги сукаме корите, бидејќи таков тарун можеби нема да биде лесно достапен за нашиот пријател. Со други зборови, повторувањето на нашите резултати генерално не треба да зависи од едиторот за текст којшто ние го користиме. 2.2 Контрола на изворен код: git Контрола на изворниот код, најчесто со git (поглавје ??), е платформата што ни дава безбедност и слобода во секоја активност поврзана со програмски код, вклучително и при анализирање и ревизирање анализи на податоци. Во основа, git e систем за undo/redo на стероиди, што може да следи две или повеќе верзии на изворниот код (гранки), од два или повеќе компјутери, овозможува соработници од различни локации истовремено да праваt поправки и унапредувања без да си ги пребришуваат промените, и дозволува да се вратите на верзијата од пред два месеци без да ги изгубите меѓувремени промени. Во денешно време е невозможно да се замисли организација која зависи од програмски код за дел од своите фунцкии без употреба на git (или друг систем на контрола на изворен код). Стриктно гледано, git не е неопходен за правење повторливи анализи. Можно е да напишеме и споделиме скрипта која обработува некои податоците без да ги следиме промените на тој код. Но имајќи во предвид дека при обработка на податоци постојано се соочуваме со одлуки и ревизии, веројатно е ќе се најдеме на брег на река каде што ќе сакаме целиот товар да го спакуваме во водоотпорена вреќа пред да ја преминеме реката. git го овозможува токму тоа и скоро сигурно ќе го користите доколку работите на транспарентната анализа на податоци. 2.3 Виртуелни контејнери: docker Иако досега зборувавме дека, во принцип, повторливите анализи се полесни доколку зависат од помалку алатки и не зависат од работната маса, оваа цел може да стане тешко остварлива, особено имајќи во предвид големите количина на различни типови на податоци (big data) кои се користат во анализи или за предикција. Оттука треба да се запознаеме и со начини на кои можеме да ги пратиме не само нашите состојки (брашно, квасец), рецепта (напишани чекори, слики), и алатки (сукало, тарун) туку и самата соба во која ја правиме питата вклучително и дрвата што ја загреваат фурната како и самата фурна. За споделување од ваков тип ќе зборуваме за docker (поглавје ??). docker е софтвер за креирање на виртуелен контејнер (пакет) кој покрај програмскиот код (R скрипти) и алатките (неопходни R пакети) може да вклучува и неопходна верзија на Rstudio и надворешни податоци. Ваков приод ни е потребен кога соработниците кои ќе сакаат да ја повторат нашата анализа користат друг оперативен систем, или не се активни корисници на R па ги немаат најновите верзии на зависностите, или едноставно кога сакаме да правиме што е можно помалку претпоставки за условите во кои нашата анализа ќе треба да биде повторена. 2.4 Резиме Корисно е да ги табулираме овие алатки во споредба со компонентите кои ги воведовме претходно во поглавје 1.1): Table 2.1: Компонентите на повторување на анализа со соодветните софтверски алатки. Аналог Компонента Алатка Состојки Податоци csv, MySQL Рецепта Изворен код R, git Алатки Зависности на кодот dplyr, ggplot2 Кујна Виртуелен контејнер docker "],["анализи-што-не-може-да-се-повторат.html", "Chapter 3 Анализи што не може да се повторат 3.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) 3.2 Типични пракси кои доведуваат до не-повторливи анализи", " Chapter 3 Анализи што не може да се повторат 3.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) Да погледнеме една хипотетичка но веројатно честа ситуација. Вие работите на некој проект што се однесува на податоци за сточарство во Македонија. Поврзани сте со локална дата база, имате големо парче податоци вчитани во меморија и работна средина со 10 закачени R пакети (библиотеки). Ви стигнува ургентна е-пошта од колега кој бара да се направи сумирање на месечните трошоци на работа групирано по тип на трошок и по вработен. Вие велите, ах, ајде ова на брзина, ги снимате податоците во Downloads и почнувате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) За пет минути сте готови со минимална дистракција, па дури и не мрднавте од претходниот проект. Ја праќате новата табела на колегата. Супер. Фала многу. Половина час подоцна стигнува е-пошта од претпоставениот со пофалба за брзо завршената работа и соработката со колегата. Шефицата исто вели ајде прати ни го кодот за да го забрзаме процесот во иднина и да не одземаме време од комплексните анализи кои ти се примарна задача. Вие го копирате кодот од историја на вашето Rstudio и го праќате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) Но, како што можеби веќе очекувате, приказната не завршува тука. Стигнува нова пошта со пораката: \"Кај мене ова не работи?!?“ Зошто? Па има неколку можни причини: Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колегите ќе ја имаат таа табела во тој фолдер? Проблем со податоците (состојките) Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колегата ќе работи на Linux а не Windows на пример, па дури и да ги имаат податоците во Downloads патеката до тој фолдер ќе биде различна (на пр. C:\\Downloads) не ~/Downloads)? Проблем со податоците (состојките) и со кодот (рецептот) Во кодот што го пративме, не вчитуваме никакви пакети, иако користиме функции од два нестандардни пакети во R: readr и dplyr. Ние не ги вчитавме овие пакети бидејќи беа закачени во проектот на којшто работевме претходно (сетете се дека не отворивме нов проект). Зошто претпоставуваме дека колегите ќе ги имаат овие пакети закачени во нивната работна средина? Проблем со кодот (рецептот) и со зависности (алатки). И иако ова личи за тривијален пример, проблемите не се тривијални. Обидете се да екстраполирате кон сериозна анализа со 500 линии код и ќе видите дека е скоро невозможно да се следи процесот и повтори анализата без далеку поголема грижа околу рецептат. Горе се главните проблеми кои ја прават нашата кратка анализа не-повторлива Но има и уште неколку дополнителни забелешки: Патеката ~/Downloads/trosoci-moja-firma.csv е со голема веројатност надвор од работната папка за било кој од вработените. Веројатнио никој не работи во Downloads, туку во фолдер наменет за различни проекти. Дополнително, многу е често папки како Downloads да се бришат/празнат со цел да не чуваме застарени датотеки коишто повторно можеме да ги симнеме. Значи за една недела, дури ни ние самите можеби нема да можеме да ја повториме анализата бидејќи датотеката ќе биде избришана. На втората команда во нашиот код, ние ја користиме функцијата summarise_at којашто е едноставен начин да дадеме инструкција да се сумираат цените. Но, зависно од верзијата на R и dplyr, функцијата summarise_at можеби нема да биде достапна. Доколку вашиот колега користи многу стара верзија на dplyr, функцијата summarise_at нема да биде дел од тој пакет со таа верзија, додека со најновата верзија на dplyr, ќе добиеме предупредување за summarise_at дека наскоро ќе биде заменета со подобра алтернатива. Се разбира овие детали не се толку битни, но веројатно е очигледна поентата дека треба да укажеме која верзија од некој пакет сме ја користеле за да може да се повтори нашата анализа. Патеката која ја користиме за да ја зачуваме табелата е фиксна, што значи ако сакаме да ја повториме процедурата за некоја втора табела, при зачувување ќе ја замениме првата зачувана табела. Значи во навидно едноставна задача, што може да се заврши со три линии код, ние прекршивме неколку правила за безбедна пракса при анализирање на податоци. Во ова сценарио, дури ни оригиналниот автор на кодот не би можел да гарантира дека ќе може да ја повтори обработката на податоците во иднина. 3.2 Типични пракси кои доведуваат до не-повторливи анализи Корисно е да споменеме некои од главните пракси кои доведуваат до ситуации како примерот погоре. Доколку при анализа на податоци некој аспект од вашата средина наликува на некоја од овие забелешки, тогаш имајте предвид дека вашата анализа може да биде проблематична за повторување. Генерално, обидете се да ги идентификувате и корегирате ваквите проблеми што е можно порано, бидејќи никој од нас не сака да менува код од стотици линии или да заменува библиотека откако сме завршиле пола од работата. Податоците и кодот не се сместени во истиот директориум. На пример податоци во C:/Data, а код во C:/Analizi. Кодот користи апсолутни патеки за вчитување или зачувување на табели (на пример: C:/Data/Мај2020/трошоци/). Ваквите апсолутни патеки со голема сигурност не се портабилни. Код без документација (коментари кои типично почнуваат со #) или README фајл кој ќе укаже како, по кој редослед да се користат скриптите и кои податоци се користат во која скрипта или кој график. Код без повикани зависности (користени библиотеки) и без информација за верзиите на повиканите зависности. Објекти со податоци кои не се експлицитно вчитани со код (укажува на податоци кои се во нашата работна средина но веројатно нема да бидат достапни за други). Работиме на нешто што вклучува случајност (randomness) но немаме наместено зачеток за генераторот на рандом бројки (set.seed во R). Ова се случува секогаш кога делиме податоци на сетови за тренирање и тестирање во машинско учење на пример. Очекуваме дека оваа листа ќе расте како што овој текст напредува понатаму. "],["conversion.html", "Chapter 4 Конверзија во повторлив код 4.1 Податоци 4.2 Први чекори кон повторливост 4.3 Функција 4.4 Rscript што може да го користиме без да отвараме R 4.5 Резиме", " Chapter 4 Конверзија во повторлив код 4.1 Податоци За да може да ги видиме следните чекори во акција неопходни ни се податоци. Табелата за трошоци има три колони (варијабли) vraboten, tip_na_trosok и cena. Еве ги првите неколку редови: trosoci ## # A tibble: 30 x 3 ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ана И. печатење 75 ## 2 Ристе Н. транспорт 81 ## 3 Ана И. печатење 13 ## 4 Благоја В. канцелариски материјали 40 ## 5 Антонија А. транспорт 89 ## 6 Љупчо В. печатење 48 ## 7 Благоја В. канцелариски материјали 96 ## 8 Љупчо В. канцелариски материјали 23 ## 9 Љупчо В. транспорт 84 ## 10 Ана И. печатење 29 ## # … with 20 more rows Трансформацијата која ја прави нашиот, сѐ уште неповторлив, код можеме исто така да ја видиме во акција: trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) ## # A tibble: 12 x 3 ## # Groups: vraboten [5] ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ана И. канцелариски материјали 31 ## 2 Ана И. печатење 177 ## 3 Ана И. транспорт 51 ## 4 Антонија А. печатење 324 ## 5 Антонија А. транспорт 111 ## 6 Благоја В. канцелариски материјали 196 ## 7 Благоја В. печатење 218 ## 8 Благоја В. транспорт 54 ## 9 Љупчо В. канцелариски материјали 23 ## 10 Љупчо В. печатење 48 ## 11 Љупчо В. транспорт 127 ## 12 Ристе Н. транспорт 116 4.2 Први чекори кон повторливост Откако сме ги согледале проблемите што доведуваат до тоа резултатот од нашиот код да не може да се повтори (без колегата да почне да чепка и кодира од почеток), можеме да интервенираме. За нашиот код да биде повторлив, минимално треба: Да ги повикува R пакетите кои се неопходни за функциите што ги користиме Да не користи апсолутни патеки за вчитување и зачувување на патоци коишто се надвор од фолдерот во кој што е сместена самата скрипта Да биде детално документиран Што се однесува до првиот проблем, кодот едноставно нема да работи без тие пакети да се вчитани па дури и нашиот колега да ги има истите фајлови на истите локации како ние. Оваа корекција е едноставна: # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) trosoci &lt;- read_csv(&quot;data/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;)%&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;data/trosoci-moja-firma-sumirani.csv&quot;) Што се однесува до втората задача, имаме повеќе можности. Можеме да побараме корисникот да ја зачува патеката во варијабла која ќе биде користена од понатамошниот код. Ова се уште дозволува патеки во друг директориум, и очигледно бара соодветна интервенција од корисникот, но ако ништо друго, корисникот на овој код, доколку ја прочита документацијата, може барем да ја повтори анализата без да добие грешки: # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # ВНИМАНИЕ: # Скриптата нема да работи доколку не внесете валидни дестинации # за фајлови за вчитување и зачувување pateka_do_input &lt;- NULL # &quot;data/trosoci-moja-firma.csv&quot; pateka_za_output &lt;- NULL # &quot;data/trosoci-moja-firma-sumirani.csv&quot; # На пример: # pateka_do_input &lt;- &quot;~/Downloads/trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;~/Downloads/trosoci-moja-firma-sumirani.csv&quot; # или: # pateka_do_input &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma-sumirani.csv&quot; # Вчитај ги податоците trosoci &lt;- read_csv(pateka_do_input) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = pateka_za_output) 4.3 Функција Алтернатива која бара малку поголема подготовка е да го напишеме функција којашто ќе работи на ист начин, земајќи ги патеките како аргументи: sumiraj_trosoci &lt;- function(trosoci, destinacija) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Често, сакаме табелата којашто ја снимаме да го има истото основно име како табелата што ја трансформираме (на пример moja-tabela.csv и moja-tabela-medijani.csv) и да се наоѓа во истиот фолдер. Со малку манипулација на текст во R (ова е уште полесно во Python) добиваме: # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Целата скрипта по овие промени би изгледала вака: # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Што сме постигнале до сега? Зависностите на кодот се решени. Документација имаме, впрочем, пишување на коментари во кодот треба да стане навика. И имаме функција на која може да и дадеме табела која што се наоѓа било каде и да зачуваме сумирана табела во истиот фолдер. 4.4 Rscript што може да го користиме без да отвараме R TODO: (for windows see: https://stackoverflow.com/questions/3506007/running-r-code-from-command-line-windows) Нашиот код е далеку подобар и има повеќе шанси да работи на други компјутери, но се уште може да се каже дека има некои недостатоци. На пример, корисникот мора да отвори R, да ја вчита скриптата, и да ја изврши функцијата. Тоа е можеби во ред доколку нашиот колега има доволно познавање од R, но можеби нашиот шеф не знае R или едноставно нема време за чепкање во R терминал. Можеби сака решение од една линија: Rscript sumiraj_trosoci.R trosoci_dekemvri_2020.csv Да го конвертираме нашиот код во ваква скрипта е лесно. Доколку кодот го процесираме со Rscript, треба само да го земеме името на фајлот даден по името на скриптата (тоа е табелата со трошоци), и да го предадеме на нашата функција (внатре во скриптата): # (data/sumiraj-trosoci-1.R) # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент dadeni_trosoci &lt;- commandArgs(trailingOnly=TRUE)[[1]] # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Доколку го тестирате кодот додека читате го имате преземено директориумот за овој текст, оваа скрипта и податоците за трошоци се наоѓаат како фолдерот data под името sumiraj-trosoci-1.R и trosoci-moja-firma.csv. Доколку сакаме навистина да се потрудиме, како поради безбедност така и поради лесно користење на ваквата скрипта, можеме да додадеме кратко упатство за користење, и код за проверка на аргументот. За да направиме упатство за користење, ќе го користиме пакетот docopt кој што користи таканаречен docstring, односно текст којшто следи некои правила за форматирање со цел да биде лесно парсиран како прирачник за употреба на нашата скрипта. docopt/docstring имаат еквиваленти во сите други програмски јазици, така да доколку програмирате во Python или Perl веројатно ви се веќе познати овие концепти. За да провериме дека се е во ред со табелата што и е дадена на скриптата, ќе го користиме пакетот assertthat, што ни овозможува лесни проверки и информативни пораки за грешката. Стриктно гледано, пакетите docopt и assertthat не се неопходни, можеме да користиме функции како commandArgs() и stopifnot() од основната дистрибуција на R. Но во некои случаи користење на додатни пакети навистина ја олеснува работата. # (data/sumiraj-trosoci-2.R) &#39;Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; sumiraj-trosoci-2.R --help sumiraj-trosoci-2.R --version Options: --help Прикажи помош --version Прикажи верзија &#39; -&gt; doc # Логика за аргументи library(docopt) arguments &lt;- docopt(doc, version = &quot;Сумирај трошоци 2.0\\n&quot;) # Провери дали табелата е csv формат assertthat::assert_that( assertthat::has_extension(arguments$tabela_so_trosoci, ext = &quot;csv&quot;)) # Вчитај ги ти пакетите кои се користат подолу suppressPackageStartupMessages({ library(dplyr) library(readr) library(assertthat) }) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # install.packages(assertthat) # Функција за групирање и сумирање трошоци # Аргументот `trosoci_tabela` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) assertthat::assert_that(inherits(trosoci, &quot;data.frame&quot;), msg = &quot;Табелата не беше вчитана како `data.frame`.&quot;) assertthat::assert_that(all(c(&quot;vraboten&quot;, &quot;tip_na_trosok&quot;, &quot;cena&quot;) %in% names(trosoci)), msg = &quot;Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;.&quot;) assertthat::assert_that(is.numeric(trosoci$cena), msg = &quot;Колоната `cena` мора да биде нумеричка.&quot;) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент (табелата) dadeni_trosoci &lt;- arguments$tabela_so_trosoci # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Со овие додатоци, нашата скрипта сега ќе може дури и да им помогне на корисниците доколку наидат на грешка. Сѐ уште не сме комплетно безбедни од не-повторливост, но стигнавме далеку имајќи во предвид каде почнавме. На пример, ако ја извршиме скриптата без аргументи: $ Rscript sumiraj-trosoci-2.R Error: Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; Execution halted Со коректен инпут: $ Rscript sumiraj-trosoci-2.R trosoci-moja-firma.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), cena = col_double() ) Со погрешен фајл, праќаме ексел наместо текстуална табела со запирки: Rscript sumiraj-trosoci-2.R trosoci-moja-firma.xls Error: File &#39;trosoci-moja-firma.xls&#39; does not have extension csv Execution halted Ако колоната за cena е крстена eur: Rscript sumiraj-trosoci-2.R trosoci-moja-firma-eur.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), eur = col_double() ) Error: Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;. Execution halted 4.5 Резиме Во ова поглавје видовме како нашите едноставни три линии код напишани набрзина можеме да ги претвориме во постабилна скрипта која веќе ги има следните карактеристики значајни за повторливост: Сите зависности на кодот се експлицитно наведени и пакетите се вчитани Скриптата не зависи од нашата работна средина Имаме далеку подобра документација, како за корисници кои ќе го отворат фајлот, така и за тие кои само ќе ја вчитаат скриптата Имаме неколку проверки/валидации на табелата што се трансформира – мора да осигураме дека табелата ги исполнува потребите пред да почнеме да сумираме Имаме автоматско составување на името за зачувување од коренот на името на табелата што ја праќаме во скриптата Сите овие чекори придонесуваат до побезбедно и одбранбено (дефенсивно) програмирање, односно пракса која ги зголемува шансите дека некој код ќе работи како што се очекува надвор од контекстот во кој бил креиран. Во овој случај, контекстот на креирање беше нашата R сесија со 10 вчитани пакети и датотека зачувана во ~/Downloads на Linux оперативен систем. Видовме дека и само еден од овие аспекти на работната средина да варира кај нашите колеги, нашата скрипта нема да работи без тие да почнат да го менуваат изворниот код. Но со наведените подобрувања ги предвидуваме и надминуваме голем дел од овие проблеми. Независно, иако направиме голем напредок кон повторлива обработка на податоци, сѐ уште правиме некакви претпоставки за контекстот во кој скриптата ќе биде користена. На пример, претпоставуваме дека сите потенцијални корисници ќе имаат табелата со трошoци, дека сите корисници ќе имаат R и Rscript инсталирано за да можат да ја извршат скриптата, и дека сите корисници ќе ги имаат инсталирано библиотеките од кои зависи нашата скрипта. Во следните поглавја ќе разгледаме начини на кои може да составиме повторливи проекти кои вклучуваат многу скрипти и податоци и прават минимални претпоставки за средината во која некој ќе се обиде да ја повтори нашата анализа. "],["повторливи-проекти.html", "Chapter 5 Повторливи проекти 5.1 Стратегија 1: Направи сам 5.2 Стратегија 2: Формален R пакет или некоја поедноставена варијанта", " Chapter 5 Повторливи проекти Во претходното поглавје разгледавме како можеме нашиот едноставен код да го конвертираме во скрипта која ќе биде лесна за користење и до некоја мера издржлива во различни работни средини. Но како што напоменавме, сеуште правиме некои претпоставки за начинот на кој ќе биде користена скриптата и за ресурсите кои ќе им бидат достапни на корисниците. Една од овие претпоставки беше дека колегите кои ќе ја користат нашата скрипта ќе имаат адекватни табели за обработување. Ова е до некоја мера разумна претпоставка доколку скриптата се користи рамките на една организација, или доколку типот на табели кои ги обработува се доволно познати и распространети. Но ваквите случаи, иако значајни, претставуваат само дел инстанците кога треба да разговараме за повторливи анализи. Да разгледаме некои примери: Пример 1: Работите во невладина организација чијшто фунцкионирање зависи од надворешни грантови, како од македонски така и од странски извори. Се почесто, донорите поставуаат услови за активностите кои тие ги подджуваат, дека сите податоци кои вашата организација ги собира (преку анкети, истражувања, и контакти) како и сите анализи на тие податоци треба да се транспарентни и повторливи (РЕФ ????: Нели има некоја ЕУ регулатива за ова). Што во пракса значи дека со завршниот извештај за проектот во кој ги презентирате резултатите, вие ќе треба исто така да покажете јавна депозиција на податоците и изворниот код користен да се добиат презентираните резултати. Со други зборови, пред вас е задача за повторлива анализа, слично на она што го видовме погоре, но со далеку повеќе код, скрипти, и податоци. Критичната разлика е во контекстот. Ако претходно претпоставуваме дека корисниците на нашиот повторлив код ќе имаат пристап до податоците, сега кога треба да ги споделиме податоците надвор од нашата организација, таа претпоставка веќе не важи. Значи ни треба начин да го споделиме нашиот програмски код заедно со податоците кои ги обработуваме, инаку никој надвор од нашата организација нема да може да ја повтори анализата. Пример 2: Работите во индустриска лабораторија каде што вашата работа е да правите статистичка обработка на експериментални резултати или анализи за контрола на квалитет. Вашата организација повторно фунцкионира преку надворешни грантови или клиенти кои очекуваат дека резултатите од вашата лабораторија ќе може да бида независно потврдени. Во пракса ова повторно значи објавување на повторлив проект, со податоци и програмски код, кој што ќе работи во контекст многу различен од вашата лабораторија. Пример 3: Накратко, бидејќи патернот е јасен. Вие сте научен истражувач на некој универзитет или институт. Вашата работа зависи од објавување трудови и аплицирање за грантови. Се поголем број на научни журнали имаат стриктни барања за транспарентни и повторливи анализи без кои нема ни да го рецензираат трудот. Вас ви треба повторлив проект. Во ова поглавје ќе се запознаеме со две стратегии за организирање на повторливи проекти. Првата стратегија (Направи сам) е едноставна за поставување и не зависи од дополнителна инфраструктура (додатни библиотеки), но ако проектот е комплексен, оваа опција може да бара повеќе грижа, особено за стабилност на подолг рок. Втората стратегија е да се повикаме на некоја веќе готова платформа за поставување на безбедна структура за повторливи проекти. Втората стратегија генерално треба да се преферира, но имајќи во предвид дека секој нов пакет си бара одреден период на запознавање и дека во некои случаи првата опција е сосема адекватна, ќе збориваме за двете стратегии. 5.1 Стратегија 1: Направи сам 5.1.1 Структура Креирање безбедна структура за повторливост во основа е едноставно. Да речеме дека имаме извештај со два графикони и три табели, и дека секој график и табела се базирани на различни сетови на податоци. Имајќи ги во предвид нашите цели: да направиме што е можно помалку претпоставки за средината во којашто ќе биде повторена нашата анализа и да направиме што е можно полесно да се снајде некој без никакво претходно искуство со нашиот проект можеме секој елемент од нашиот извештај да го енкапсулираме во посебен фолдер. Во секој фолдер мора да ги вклучиме податоците и програмскиот код коишто се неопходни за ре-креирање на графиконот или табелата. За детални објаснувања, можеме во (фали нешто тука?) да вклучиме README фалј во оние фолдери каде што е неопходно. Главен README фалј на првото ниво на нашиот проект мора да биде вклучен. Тука, го опишуваме нашиот проект, што подетално тоа подобро, и даваме објаснување за како да се користат податоците и кодот којшто е вклучен во субфолдерите. Ова е особено важно доколку скриптите зависат една од друга и треба да се извршат во некој редослед, на пример ако мора прво да го извршиме кодот во tabela_1 пред да можеме да работиме со tabela_2. Во нашиот случај, со два графикони и три табели сите со различни податоци, би ја имаме следната структура: strategija_1/ ├── grafik_1 │   ├── code_grafik_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   └── data_grafik_2.csv ├── README ├── tabela_1 │   ├── code_tabela_1.R │   └── data_tabela_1.csv ├── tabela_2 │   ├── code_tabela_2.R │   └── data_tabela_2.csv └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Доколку графиконите 1 и 2 се базирани на исти податоци како табелите 1 и 2, тогаш можеме да ги групираме, со што би избегнало непотребно копирање на истите податоци на две места: strategija_1/ ├── grafik_1 │   ├── code_grafik_1.R │   ├── code_tabela_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   ├── code_tabela_2.R │   └── data_grafik_2.csv ├── README └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Но генерално, при одлучување за структурата на проектот треба да си го поставиме прашањето „како најлесно ќе се снајде некој што никогаш претходно нема работено со овие податоци или тип на анализи?“. Доколку одговорот на ова прашање сугерира да се копираат истите податоци на две места, и податоците се доволно мали да го дозволат тоа, тогаш е подобро да се направи вишокот отколку да се направи ре-анализата покомплицирана. 5.1.2 Предности Како оваа стратегија овозможува повторливост? Доколку нашиот код ги следи принципите за кои збориваме претходно, спарувањето на податоците со кодот што треба да се користи за нивна обработка во еден фолдер изолирани од остатокот на проектот значи дека: шансите корисникот на нашиот проект да ги помеша фајловите се минимални, нашиот код може да биде поедноставен бидејќи вчитува податоци во истиот фолдер, и конечно сите резултати од извршувањето на нашиот код (на пример пдф од графикон) ќе се зачуваат во истиот фолдер. Оваа едноставна, линеарна поврзаност е веројатно најбезбедна од аспект на поставување и користење подоцна од некој кој нема никакво претходно познавање. Дополнително, ваквата структура овозможува модуларност, во смисла на тоа дека секоја табела или графикон може да се ре-креира независно од остатокот на анализата, ако, на пример, нашиот соработник или рецензент сака да провери само одреден аспект на истражувањето. 5.1.3 Недостатоци Главните недостатоци на оваа стратегија се непотребното повторување на код или податоци (не секогаш, но често), и тоа што оваа организација станува незгодна ако имаме голем или комплициран извештај со многу анализи коишто би сакале да ги одделиме. Можното непотребно повторување да податоци веќе спомнавме погоре како разлика помеѓу недостатоците на дуплицирање наспроти предноста што копирањето на една табела на две места може да подобри леснотијата на користење. Имено, доколку некоја скрипта има соодветно именувана табела што ја користи во соодветно именуван фолдер, тогаш дури и истата табела да се јави под друго име во друг фолдер каде што се отвара од друга скрипта, тоа не создава забуна. Од друга страна, доколку истата табела, под исто име, се наоѓа во заедничи фолдер Табели, тогаш треба за двете скрипти да објасниме дека ја користат истата табела и двете скрипти треба да повикуваат табела што е сместена надвор од соодветните фолдери. Второто сценарио е малку покомплицирано, и доколку табелата во прашање е доволно мала (во смисол на меморија) тогаш од перспектива на корисник кој прв пат го гледа проектот можеби не е проблем доколку се јавува два пати. Сепак, генералната препорака е дека најдобро е да се избегне дупликација на податоци, бидејќи податоците се (типично) најголемиот (во смисол на меморија) дел од нашиот пакет, а сакаме нашиот пакет да биде што попортабилен. За повторувањето на програмски код имаме слична дилема. Доколку нашите табели или графици, кои ги правиме со посебни скрипти во посебни фолдери, имаат делови со идентичен код (на пример сите скрипти ги прават истите проверки за табелите, или сите скрипти за табела ја прават истата сумација по групи), тогаш можеме делот од кодот што се повторува да го изолираме во посебна скрипта што сите други скрипти ќе ја повикуваат. Оваа опција е подобра бидејќи доколку најдеме грешка или сакаме да направиме некое подобрување, тоа го правиме само во скриптата со заеднички код, додека пак доколку тој код се дуплицира во повеќе скрипти, ќе треба да ги промениме сите. Во ваков случај со изолиран заеднички код, нашата структура може да се промени во нешто налик на следниот дијаграм. strategija_1/ ├── README ├── zaednicki-kod.R ├── grafik_1 │   ├── code_grafik_1.R │   ├── code_tabela_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   ├── code_tabela_2.R │   └── data_grafik_2.csv └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Вториот недостаток, незгодноста кога проектот станува голем и комплициран, станува јасен со претходниот дијаграм. Кога скриптите, и фунцкии внатре во скриптите, почнуваат да стануваат зависни една од друга, предностите на линерано изолирање на кодот и податоците почнуваат да се смалуваат. На пример, ако code_tabela_3.R има функција sumiraj-po-grupi() која повикува две функции од zaednicki-kod.R и ја вчитува табелата што резултира од модулот grafik_2, тогаш немаме баш линеарна зависност туку нешто покомплицирано. И иако сеуште можеме рачно да ги организираме ваквите врски помеѓу код и податоци, веројатно е време да разгледаме други опции за организирање на нашиот проект. 5.2 Стратегија 2: Формален R пакет или некоја поедноставена варијанта 5.2.1 Структура Разгледувајќи ја првата стратегија за организирање на повторливи проекти дојдовме до моментот кога зависностите помеѓу нашиот код и податоци почнуваа да стануваат не-линеарни. Од една страна, неколку скрипти можат да ги користат истите податоци и да повикуваат функции од една скрипта за заеднички код, од друга страна, една скрипта може да зависи од резултатите на повеќе други прекурсори. Кога нашиот проект ќе ја стигне оваа фаза, тогаш подобро е да ја напуштиме линеарната структура што изолира еден сет на податоците и нивната обработка од остатокот на пакетот и да го реорганизираме проектот така што податоците, кодот, извештате, итн, ќе бидат во засебни фолдери. Во овој случај, структурата на проектот може да биде нешто налик на следниот дијаграм: strategija_2/ ├── izvestai ├── podatoci ├── README └── skripti Доколку некогаш сте ја погледнале структурата на еден формален R пакет (под „формален„ мислиме пакет или библиотека која што може да се инсталира и повика со library(mojpaket)), веднаш ќе ги забележите сличностите: Структура на еден формален R пакет (библиотека) Сиот програмски код е изолиран во посебен фолдер (skripti/R), податоците се во фолдери посветени на податоци (podatoci/data/data-raw), главниот директориум во двата случаи има README фајл кој ја објаснува намената на пакетот и укажува како може да се користат спакувануте компоненти, итн. Како работиме во оваа средина? Без разлика колку скрипти имаме, со колку функции во нив, и колку комплексни се зависностите помеѓу нив: сите тие скрипти ги вчитуваме во нашата R средина (global environment, .GlobalEnv), така што кога една фунција повикува втора функција не мора да се сетиме во која сктипта живее таа функција сите тие скрипти вчитуваат податоци кои се наоѓаат во podatoci и никаде на друго место сите тие скрипти зачувуваат подукти (табели, графици, HTML/PDF извештаи во izvestai) На ваков начин, ја елиминараме потрабата од копирање на податоци или код, и секоја компонента, дали е тоа изворен код или податоци, се јавува само еднаш во нашиот пакет. 5.2.2 Поставување Поставувањето на ваков повторлив проект може повторно да оди рачно, едноставно правиме фолдери за податоци, изборен код, итн. Но исто таке можеме да искористиме постоечки функции и пакети кои го прават овој чекор полесен. Иако има многу решенија достапни решенија, ќе тука ќе споменеме две опции. Прво, можеме да ја искористиме функционалноста за креирање формални R пакети, дури немаме намера да го објавуваме нашиот пакет. Кодот е едноставен: library(devtools) library(usethis) devtoos::create(path = &quot;mojpaket&quot;) podatoci1 &lt;- read.csv(&quot;~/Desktop/moi-podatoci.csv&quot;) usethis::use_data(&quot;podatoci1&quot;) Извршувањето на горните линии ќе креира структура налик на следната: mojpaket/ ├── DESCRIPTION ├── NAMESPACE ├── data └── R Понатаму, како додавате документација, вињети, или тестови, можете да генерирате соодветни фолдери полу-автоматски. За далеку повеќе детали околу овие процедури, ве повикуваме да ја погледнете книгата за R пакети од Хадли Викам ((Wickham 2015)). Втората опција за креирање на ваква структура за репродуцибилен проект преку користење на пакети посветени кон токму тоа: да олеснат повторливи анализи/истражувања/извештаи преку автоматизирање на некој од компонентите на повторливост кои ги дискутиравме до сега. Има повеќе вакви пакети: prodigenr, makeProject, ProjectTemplate, fertile, goodpractice, кои специјализираат кон различни аспекти (дали структура на проектот, проверки на кодот, итн). Овде, накратко, ќе се запознаеме со основната функционалност на пакетот prodigenr кој овозможува креирање на структура налик на формален R пакет но без (понекогаш непотребниот) багаж кој доаѓа со развивањето и користењето на еден формален R пакет. library(prodigenr) setup_project(&quot;data/mojproekt2&quot;) Потоа, доколку го погледнеме направениот проект ја имаме следната структура: mojproekt2/ ├── data │   └── README.md ├── DESCRIPTION ├── doc │   └── README.md ├── mojproekt2.Rproj ├── R │   ├── fetch_data.R │   ├── README.md │   └── setup.R ├── README.md └── TODO.md На пример, скриптата setup.R доаѓа со објаснување како да ги организираме нашите скрипти/функции со цел да бидат достапни за време на интерактивната сесија. Додека пак скриптата fetch_data.R не насочува кон тоа како да ги собираме и подготвиме табелите со податоци за зачувување во data/ и понатамошно користење. Како и во еден формален пакет, фајлот DESCRIPTION дава инструкции за зависностите на нашиот код (не-стандардни R пакети). Како и секогаш, ве покануваме да ја прочитате документацијата на пакетот (на пример `library(help=“prodigenr”)) за повеќе детали. 5.2.3 Предности Очигледно има добри причини зошто би сакале нашиот повторлив проект да има структура слична на формален R пакет. Еден R пакет може да се инсталира и користи без проблем на било кој компјутер, има ефективна документација со вградени упатства за употреба и подолги вињети за специјални случаи, има екплицитно менаџирање на зависностите, и единични тестови (unit tests) кои што проверуваат дали секоја фунцкија го дава очекуваниот резултат во различни контексти. 5.2.4 Недостатоци Може да се најдат недостатоци во било кој систем, и секако оваа структура може сеуште да се подобрува, но за робустна организација на вашите повторливи проекти веројатно треба да се држите до некоја од алтернативите дискутирани тука. Она што може да се спомене, не како недостаток, туку предупредување, е дека навинкувањето и целосно искористување на ова структура ќе бара малку повеќе време и учење, како за оној кој го подготвува проектот така и за корисниците. "],["references.html", "References", " References "],["повторливи-документи-извештаи-rmd.html", "Chapter 6 Повторливи документи / извештаи (Rmd)", " Chapter 6 Повторливи документи / извештаи (Rmd) "],["note-i-think-this-should-be-a-subsection-of-the-previous-chapter.html", "Chapter 7 note: i think this should be a subsection of the previous chapter 7.1 referenca: https://emilyriederer.netlify.app/post/rmarkdown-driven-development/ 7.2 da go prevedeme ova li: https://r4ds.had.co.nz/r-markdown.html ne znam", " Chapter 7 note: i think this should be a subsection of the previous chapter Речиси никогаш не е доволно само да се испрати (или објави) една табела или пресметка. Речиси секој пат потребно е да се додаде објаснување или некаков друг контекст на податоците. Тоа најчесто се прави со текст. За едноставно комбинирање на код, податоци, резултати и текст во еден документ, светот на R се користи Rmarkdown. Патем, така е напишан и овој прирачник. Rmarkdown овозможува комбинирање на сите елементи на едно истражување во документ погоден за понатамошно споделување. 7.1 referenca: https://emilyriederer.netlify.app/post/rmarkdown-driven-development/ 7.2 da go prevedeme ova li: https://r4ds.had.co.nz/r-markdown.html ne znam "],["контрола-на-изворниот-код-git-github.html", "Chapter 8 Контрола на изворниот код (git / GitHub)", " Chapter 8 Контрола на изворниот код (git / GitHub) Git е последната алатка … "],["not-too-much-about-git-of-course-that-is-not-the-point-anyway.html", "Chapter 9 not too much about git (of course that is not the point anyway)", " Chapter 9 not too much about git (of course that is not the point anyway) "],["just-about-creating-a-github-repo-where-you-can-push-rmd-in-main-and-html-in-gh-pages-thus-making-your-reserarch-public-on-the-web-mostly-working-thourgh-r-studio-exept-for-creating-the-account-on-gh-.html", "Chapter 10 just about creating a github repo where you can push rmd in main and html in gh-pages thus making your reserarch public on the web mostly working thourgh r studio exept for creating the account on gh.", " Chapter 10 just about creating a github repo where you can push rmd in main and html in gh-pages thus making your reserarch public on the web mostly working thourgh r studio exept for creating the account on gh. 10.0.1 референци: https://git-scm.com/book/en/v2 Allaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Chang, Winston, Joe Cheng, JJ Allaire, Yihui Xie, and Jonathan McPherson. 2020. Shiny: Web Application Framework for r. http://shiny.rstudio.com. Dowle, Matt, and Arun Srinivasan. 2019. Data.table: Extension of ‘data.frame‘. https://CRAN.R-project.org/package=data.table. Wickham, Hadley. 2015. R Packages: Organize, Test, Document, and Share Your Code. \" O’Reilly Media, Inc.\". Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2020. Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggplot2. Wickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Xie, Yihui. 2020a. Blogdown: Create Blogs and Websites with r Markdown. https://github.com/rstudio/blogdown. ———. 2020b. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. ———. 2020b. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. "]]

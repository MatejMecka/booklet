[["index.html", "Препораки за репродуцибилно анализирање на податоци Chapter 1 План:", " Препораки за репродуцибилно анализирање на податоци Теофил Наков, Новица Наков 11/25/2020 Chapter 1 План: title: Препораки за репродуцибилно ракување, анализирање, и објавување на податоци more realistic title: Препораки за репродуцибилно анализирање на податоци c1: Вовед c2: Алатки c3: Типична анализа (која никој, дури ни авторот, не може да ја повтори) c4: Брза конверзија во репродуцибилна анализа: Скрипта c5: Репродуцибилни документи / извештаи (Rmd) c6: Контрола на изворниот код (git / GitHub) c7: Што ако вашиот колега има Mac, или друга верзија на R? Docker. c8: Заклучок c9: Литература "],["intro.html", "Chapter 2 Вовед 2.1 Аналогија 2.2 Организација", " Chapter 2 Вовед Овој текст е обид да се направи преглед и понудат препораки за безбедна пракса при ракување, анализирање, и објавување на податоци. Под „безбедна пракса“ подразбираме чекори кои доколку ги следиме ќе имаме некаква сигурност дека резултатот кој ние го презентираме може било кој да го добие доколку ги користи истите податоци и следи истите процедури кои ги објавуваме заедно со резултатот. Се чини дека оваа поента е доволно очигледна да некој би рекол дека и воопшто нема потреба да се зборува за ова. Сите се согласуваме со тоа дека кога нашата колешка ќе направи некаква анализа, ние, доколку имаме доволно информации за нејзината анализа, можеме да ја повториме и да ги добиреме истите резултати. Но во пракса оваа удобна идеја ретко кога се остварува. Наместо репродуцибилност, кога се обидуваме да повториме некоја анализа, вообичаено е да се соочиме со забуна и фрустрација. Ова често завршува со откажување или правење на анализата од почеток, односно, безполезно и контрапродуктивно губење на време, ресурси, пари, итн. Горната дефиниција на „безбедна пракса“ (без преправање дека ова е некаква прецизна дефиниција) повикува барем две дополнителни поенти за тоа што подразбира да анализираме податоци и објавувиме резултати на начин што овозможува точно повторување. Имено, објавувањето на резултат мора да биде поддржано со објавување на 1) точните податоци кои биле употребени да се направи анализата, и 2) деталната процедура која била извршена за да се добие резултатот. Подоцна ќе видиме зошто се неопходни овие компоненти (иако веруваме дека е горе-доле очигледно) и на кој начин е најдобро да се презентираат/објават. Тука е можеби полезно да направиме разлика помеѓу репродуцибилноста која ја опишуваме до сега и еден друг тип на повторливост што има поголема фундаменталност и тежина. Во природните науки, кога зборуваме за нешто што е научна вистина или научно знаење, скоро секогаш тоа се однесува на резултати кои се повторливи и можат да се докажат од различни агли. Дали почнувајќи со различни податоци, или со поставување на нови експерименти, или со употреба поинакви анализи, критично е да дојдеме до истиот резултат за тој да биде прифатен како една компонента од тоа како светот функционира (научна вистина). На пример, дека Земјата е сферична може да се докаже со податоци од циркумнавигација, со мерење на аголот на сончевите зрази на различни географски локации, со движењето на Фуковото нишало, со самото постоење на ГПС навигација, со фотографии од возила во орбита, и така натаму. Значи истиот резултат можеме ги изведеме од многу различни податоци и методи. За разлика од ваквата репликација, фокусот на овој текст е поскромен, и се однесува на далеку полесниот концепт на повторување истата рецепта, со истите составки, за да ја направиме истата пита. 2.1 Аналогија Проширување на горната аналогија е добар начин да се запознаеме со главните компоненти на репродуцибилната обработка на податоци. Кога правиме пита имаме состојки (брашно, квасец, зелје, сирење, …), рецепта со неколку чекори (нарасни го квасецот, замеси тесто, насукај кори), и неопходни алатки (лонче, тарун, тепсија, фурна). Кога сакаме да ја направиме истата пита што ја прави баба му на нашиот пријател, треба да ги имаме сите состојки, информации за сите чекори за подготовка, и сите алатки. Ако имаме брашно, вода, и сол ама сме заборавиле квасец, нема да може да замесиме тесто. Ако немаме сукало, ќе треба да тегнеме кори, што секако ќе значи поинаква пита. Значи за да ја повториме питата, потребно е да ги имаме сите неопходни елементи и инфмормации кои ќе овозможат точно повторување на секој чекор. Затоа не е чудно што рецепти за готвење често доаѓаат со слики или видео. Тоа се медиуми побогати со инфромации и атоа поадекватни за пренесување комплексни процеси како правење пита. Безразлика колку детално некој опишал како се сука кора со радиус од 25 cm, со видео од процесот ние добиваме далеку подобро разбирање за процедурата. Во сферата на анализа за податоци, аналозите на горните компоненти се: податоците ~ состојки изворниот код ~ рецепта и софтверски пакети од кои зависи нашиот код ~ алатки На пример, ако правиме анализа на невработеност низ Северна Македонија, и имаме една табела со невработеност по општини но сме ги групирале податоците по градови користејќи друга табела, тогаш за точна репликација на нашата анализа треба да ги споделиме двете табели (и брашното и квасецот). Слично, за некој ги направи истите графици за невработеност по град, треба да го споделиме и нашиот код за правење на анализата (рецептата), како и информации за софтверот во кој сме го извршиле тој код (тарунот). Некогаш тарунот не е неопходен за да се направи истата пита, можеби само температурата на фурната е битна, и во ваквите случаи можеме да ја споделиме рецептата без рестрикција за алатката што треба да се користи. Но во други случаи, дури и да се достапни точните податоци и документираниот изворен код, анализата не може да се повтори без некоја специјална алатка. Во овие случаи ние би требало да ги спакуваме и споделиме дури и нашите алатки. За среќа, аналогијата помеѓу правење пита и повторување на некоја анализа завршува со споделувањето на податоците, кодот, и информации за алаткити. Имајќи пристап до овие компоненти, дури и никогаш да не сте правеле некаква специфична анализа во некој специфичен софтвер, вие сепак ќе можете да ги извршите истите документирани чекори и дојдете до истиот резултат. Повторувањето на анализата не бара пракса, вичност, искуство, и не зависи од тоа колку е влажно брашното. Ако креирањето репродуцибилни документи или анализи ви звучеше како комплициран концепт, се надеваме дека со оваа аналогија станува јасно дека е далеку полесено од обидот да се направи пита како како баба му на пријателот или пица како од ресторан. 2.2 Организација Темата на овој текст е доволно опширна да тука нема ни да се обидеме да дадеме севкупен третмант на сите значајни аспекти. Туку, целта е да дадеме преглед на главните принципи за повторливи анализи и практични примери за главните препораки. По воведот, прво ќе се запознаеме со софтверските алатки кои ќе ги користиме понатаму (Поглавје 2: Алатки), и ќе посочиме некои од најчестите случаи кога една анализа, дури и да имаме најдобри намери, може да биде “неповторлива“ (Поглавје 3: Чести проблеми и … ???). Понатаму ќе ги разгледаме главните начини на кои постоечки, нерепродуцибилен код за некоја анализа може да се конвертира во репродуцибилна анализа (Поглавје 4: Брза конверзија во репродуцибилна анализа: Скрипта) и за пишување на документи кои ги покажуваат нашето размислување, претпоставки, хипотези, заедно со кодот што го користиме за нивно тестирање и резултатите од тие тестови (Поглавје 5: Репродуцибилни документи / извештаи (Rmd)). За крај, ќе зборуваме за контола на изворниот код со git што ни дава слобода и безбедност за променување и подобрување (Поглавје 6: Контрола на изворниот код (git / GitHub)) и за случаевите кога дури и се околу нашата анализа да е репродуцибилно, некој едноставно не може да ја повтори нашата анализа бидејќи нема пристап до алатките кои ние го користиме (Поглавке 7: Што ако вашиот колега има Mac, или друга верзија на R? Docker.). Текстот го затвораме со заклучок и литература со препорака да во најмала рака ги погледнете ресурсите дадени во библиографијата бидејќи сорджат далеку подетални и ефективни третмани на темата на репродуцибилно ракување, анализирање и објавување на податоци. "],["tools.html", "Chapter 3 Алатки 3.1 Програмски јазик: R 3.2 Контрола на изворен код: git 3.3 Виртуелни контејнери: docker 3.4 Сиже", " Chapter 3 Алатки 3.1 Програмски јазик: R Генерално гледано, во денешно време, доколку анализирате податоци тоа вероратно го правите со помош на Python (и пакети како: pandas, numpy, matplotlib) или Р (со пакети како: dplyr, data.table, ggplot2). Доколку работите на пониско ниво или вашата работа е поблиска до математика, можеби користите c# за забрзување на вашиот код, но генерално, ретко кога јазик од типот на c# сe користи за интерактивна анализа на податоци, графирање, или машинско учење. Конечно понови јазици, како Julia и Scala имаат дополнителни предности со тоа што овозможуваат полесно пишување код во експлоративни сесии како Python ili R но со брзина на компутација што е поблиска до c или c#. Во секој случај, препораките дадени во овој текст се апликабилни без разлика на програмскиот јазик што го користите. Во овој текст генерално ќе работиме со софтверски алатки од R екосистемот. R е програмски јазик пред се наменет кон статистички анализи, и иако не е најраспространет или најшироко користен, е од особено значење за анализа на податоци, и следствено репродуцибилна анализа на податоци. Главните причини за употребата на R се дека авторите на овој текст секојдневно користат R и Rstudio и поради тоа што има еден куп дополнителни екстензии во оваа средина кои овозможуваат лесно пишување технички извештаи, научни трудови (Rmarkdown), книги (bookdown), веб апликации (shiny), блогови (blogdown), итн. Самиот овој текст го пишувамe со помош на bookdown, што овозможува неверојатно лесно составање и објавивање на подолги текстови (книги) со поглавја, компјутерски код, и математичка нотација со едно копче во Rstudio. Во овој текст немаме намера да навлегуваме длабоко во самото кодирање во R. Нашиот приод ќе биде да објасниме одреден принцип со обични зборови и да покажеме како тоа би можело да изгледа со R код. Што значи дури и да не знаете ништо за R би можеле да го следите текстот и употребите препораките во вашиот омилен програмски јазик за обработка на податоци. Во некој делови ќе користиме материјали кои се специфични за R и Rstudio (на пример Rmarkdown) така да можеби ќе има технички детали кои нема да може да директно да ги примените во Jypiter тетратка или доколку работите во друг текст едитор (VScode). Но повторно, имајќи во предвид дека препораките ќе тежнеат кон тоа како да пишуваме код кој ќе бара минимална интервенција при (ре)анализа на податоци, ваквите аспекти специфични за Rstudio ќе бидат сведени на минимум. Генерално, целта ни е да креираме пакет (фолдер) за правење пита што вклучува се што е неопходно за да нашиот пријател може без многу мислење да ја направи истата пита. За да го олесниме овој процес, треба да се стремиме кон тоа да не користиме специјален тарун (софтвер) за да ги сукаме корите, бидејќи таков тарун можеби нема да биде лесно достапен за нашиот пријател. Со други зборови, повторувањето на нашите резултати генерално не треба да зависи од едиторот за текст кој ние го користиме. 3.2 Контрола на изворен код: git Контрола на изворниот код, најчесто со git (поглавје ??), е платформата што ни дава безбедност и слобода во секоја активност поврзана со програмски код, вклучително и при анализирање и ревизирање анализи на податоци. Во основа, git e систем за undo/redo на стероиди, што може да следи две или повеќе верзии на изворниот код (гранки), од два или повеќе компјутери, овозможува соработници од различни локации истовремено да праваt поправки и унапредувања без да си ги пребришуваат промените, и дозволува да се вратите на верзијата од пред два месеци без да ги изгубите меѓувремени промени. Во денешно време е невозможно да се замисли организација која зависи од програмски код за дел од своите фунцкии без употреба на git (или друг систем на контрола на изворен код). Стриктно гледано, git не е неопходен за правење репродуцибилни анализи. Можно е да напишеме и споделиме скрипта која обработува некои податоците без да ги следиме промените на тој код. Но имајќи во предвид дека при обработка на податоци постојано се соочуваме со одлуки и ревизии, веројатно е ќе се најдеме на брег на река каде што ќе сакаме целиот товар да го спакуваме во водоотпорена вреќа пред да ја преминеме реката. git го овозможува токму тоа и скоро сигурно ќе го користите доколку работите на транспарентната анализа на податоци. 3.3 Виртуелни контејнери: docker Иако досега зборувавме дека, во принцип, репродуцибилните анализи се полесни доколку зависат од помалку алатки и не зависат од работната маса, оваа цел може да стане тешко остварлива, особено имајќи во предвид големите количина на различни типови на податоци (big data) кои се користат во анализи или за предикција. Оттука треба да се запознаеме и со начини на кои можеме да ги пратиме не само нашите состојки (брашно, квасец), рецепта (напишани чекори, слики), и алатки (сукало, тарун) туку и самата соба во која ја правиме питата вклучително и дрвата што ја загреваат фурната како и самата фурна. За споделување од ваков тип ќе зборуваме за docker (поглавје ??). docker е софтвер за креирање на виртуелен контејнер (пакет) кој покрај програмскиот код (R скрипти) и алатките (неопходни R пакети) може да вклучува и неопходна верзија на Rstudio и надворешни податоци. Ваков приод ни е потребен кога соработниците кои ќе сакаат да ја повторат нашата анализа користат друг оперативен систем, или не се активни корисници на R па ги немаат најновите верзии на зависностите, или едноставно кога сакаме да правиме што е можно помалку претпоставки за условите во кои нашата анализа ќе треба да биде повторена. 3.4 Сиже Корисно е да ги табулираме овие алатки во споредба со компонентите кои ги воведовме претходно во поглавје 2.1): Table 3.1: Компонентите на повторување на анализа со соодветните софтверски алатки. Аналог Компонента Алатка Состојки Податоци csv, MySQL Рецепта Изворен код R, git Алатки Зависности на кодот dplyr, ggplot2 Виртуелен контејнер docker "],["не-репродуцибилни-анализи.html", "Chapter 4 Не-репродуцибилни анализи 4.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) 4.2 Типични пракси кои доведуваат до не-репродуцибилни анализи", " Chapter 4 Не-репродуцибилни анализи 4.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) Да погледнеме една хипотетичка но веројатно честа ситуација. Вие работите на некој проект што се однесува на податоци за сточарство во Македонија. Поврзани сте со локална дата база, имате големо парче податоци во качени меморија, и работна средина со 10 закачени R пакети (библиотеки). Ви стигнува ургентна е-пошта од колега кои бараат да се направи сумирање на месечните трошоци на работа групирано по тип на трошок и по вработен. Вие велите, ах, ова ајде на брзина, ги снимате податоците во Downloads и почнувате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) За пет минути сте готови со минимална дистракција, па дури и не мрднавте од претходниот проект. Ја праќате новата табела на колегата. Супер. Фала многу. Пола саат подоцна стигнува е-пошта од претпоставениот со пофалба за брзо завршената работа и соработката со колегата. Шефицата исто вели ајде прати ни го кодот за да го забрзаме процесот во иднина и да не одземаме време од комплексните анализи кои ти се примарна задача. Вие го копирате кодо од историја на вашето Rstudio и го праќате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) Но, како што можеби веќе очекувате, приказната не завршува тука. Стигнува нова пошта со пораката: \"Кај мене ова не работи?!?“ Зошто? Па има неколку можни причини: Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колагите ќе ја имаат таа табела во тој фолдер? Проблем со податоците (состојките) Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колегата ќе работи на Linux а не Windows на пример, па дури и да ги имаат податоците во Downloads патеката до тој фолдер ќе биде различна (на пр. C:\\Downloads) не ~/Downloads)? Проблем со податоците (состојките) и со кодот (рецептата) Во кодот што го пративме, не повикуваме никакви пакети, иако користиме функции од два не-стандардни пакети во R: readr и dplyr. Ние не ги повикавме овие пакети бидејќи беа закачени во проектотот на кој работевме претходно (сететесе дека не отворивме нов проект). Зошто претпоставуваме дека колегите ќе ги имаат овие пакети закачени во нивната работна средина? Проблем со кодот (рецептата) и со зависности (алатки). И иако ова личи за тривијален пример, проблемите не се тривијални. Обидете се да екстраполирате кон сериозна анализа со 500 линии код и ќе видите дека е скоро невозможно да се следи процесот и репродуцира анализата без далеку поголема грижа околу рецептат. Горе се главните проблеми кои ја прават нашата кратка анализа не-репродуцибилна. Но има и уште неколку дополнителни забелешки: Патеката ~/Downloads/trosoci-moja-firma.csv е со голема веројатност надвор од работната папка за било кој од вработените. Веројанто никој не работи во Downloads, туку во фолдер наменети за различни проекти. Дополнително, многу често папки како Downloads да се бришат/празнат со цел да не чуваме застарени датотеки кои може повторно да ги симнеме. Значи за една недела, дури ни ние самите можеби нема да можеме да ја повториме анализата бидејќи датотеката ќе биде избришана. На втората команда во нашиот код, ние ја користиме функцијата summarise_at што е цонвениент начин за да дадеме инструкција да се сумираат цените. Но, зависно од верзијата на R и dplyr, функцијата summarise_at можеби нема да биде достапна. Доколку вашиот колега користи многу стара верзија на dplyr, функцијата summarise_at нема да биде дел од тој пакет со таа верзија, додека со најновата верзија на dplyr, ќе добиеме предупредување за summarise_at дека наскоро ќе биде заменета со подобра алтернатива. Се разбира овие детали не се толку битни, но веројатно е очигледна поентата дека треба да укажеме која верзија од некоја пакет сме ја користеле за да може да се повтори нашата анализа. Патеката која ја користиме за да ја зачуваме табелата е фиксна, што значи ако сакаме да ја повториме процедурата за некоја втора табела, при зачувување ќе ја замениме првата зачувана табела. Значи во навидно едноставна задача, што може да се заврши со три линии код, ние прекршивме неколку правила за безбедна пракса при анализирање на податоци. Во ова сценарио, дури ни оригиналиот автор на кодот не може да гарантира дека ќе може да ја повтори обработката на податоците во иднина. 4.2 Типични пракси кои доведуваат до не-репродуцибилни анализи Корисно е да споменеме некои од главните пракси кои доведуваат до ситуации како примерот погоре. Доколку при анализа на податоци, некој аспект од вашата средина наликува на некоја од овие забелешки, тогаш имајќе во предвид дека вашата анализа може да биде проблематична за повторување. Генерално, обидете се да ги идентификувате и корегирате ваквите проблеми што е можно порано, бидејќи никој од нас не сака да менува код од стотици линии или да заменува библиотека откако сме завршиле пола од работа. Податоците и кодот не се сместени во истиот директориум. На пример податоци во C:/Data а код во C:/Analizi Кодот користи апсолутни патеки за вчитување или зачувување на табели (на пример: C:/Data/Мај2020/трошоци/). Ваквите апсолутни патеки со голема сигурност не се портабилни Код без документација (коментари кои типично почнуваат со #) или README фајл кој ќе укаже како, во кој редослед, да се користат скриптите и кои податоци се користат во која скрипта или кој график Код без повикани зависности (користени библиотеки) и без информација за верзиите на повиканите зависности Објекти со податоци кои не се експлицитно вчитани со код (укажува на податоци кои се во нашата работна средина но веројатно нема да бидата достапни за други) Работиме на нешто што вклучува randomness но немаме наместено зачеток за генераторот на рандом бројки (set.seed во R). Ова се случува секогаш кога делиме податоци на сетови за тренирање и тестирање во машинско учење на пример. Очекуваме дека оваа листа ќе расте како напредува овој текст и подоцна. "],["conversion.html", "Chapter 5 Конверзија во репродуктивен код 5.1 Податоци 5.2 Први чекори кон репродуцибилност 5.3 Функција 5.4 Rscript што може да го користиме без да отвараме R", " Chapter 5 Конверзија во репродуктивен код 5.1 Податоци За да може да ги видиме следните чекори во акција, неопходни ни се податоци. Табелата за трошоци има три колони (варијабли) vraboten, tip_na_trosok и cena. Еве ги првите неколку редови: trosoci ## # A tibble: 30 x 3 ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Ана И. печатење 75 ## 2 Ристе Н. транспорт 81 ## 3 Ана И. печатење 13 ## 4 Благоја В. канцелариски материјали 40 ## 5 Антонија А. транспорт 89 ## 6 Љупчо В. печатење 48 ## 7 Благоја В. канцелариски материјали 96 ## 8 Љупчо В. канцелариски материјали 23 ## 9 Љупчо В. транспорт 84 ## 10 Ана И. печатење 29 ## # … with 20 more rows Трансформацијата која ја прави нашиот, сеуште не рерподуцибилен, код можеме исто така да ја видиме во акција: trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) ## # A tibble: 12 x 3 ## # Groups: vraboten [5] ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Ана И. канцелариски материјали 31 ## 2 Ана И. печатење 177 ## 3 Ана И. транспорт 51 ## 4 Антонија А. печатење 324 ## 5 Антонија А. транспорт 111 ## 6 Благоја В. канцелариски материјали 196 ## 7 Благоја В. печатење 218 ## 8 Благоја В. транспорт 54 ## 9 Љупчо В. канцелариски материјали 23 ## 10 Љупчо В. печатење 48 ## 11 Љупчо В. транспорт 127 ## 12 Ристе Н. транспорт 116 5.2 Први чекори кон репродуцибилност Откако сме ги согледале проблемите што доведуваат до тоа резултатот од нашиот код да не може да се повтори (без колегата да почне да чепка и кодира од почеток), можеме да интервенираме. За нашиот код да биде репродуцибилен, минимално треба: Да ги повикува R пакетите кои се неопходни за функциите што ги користиме Да не користи апсолутни патеки за вчитување и зачувување на патоци кои се надвор од фолдерот во кој што е сместена самата скрипта Да биде детално документиран Што се однесува до првиот проблем, кодот едноставно нема да работи без тие пакети да се закачени. Дури и нашиот колега да ги има истите фајлови на истите локации како ние. Оваа корекција е едноставна: # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) trosoci &lt;- read_csv(&quot;data/trosoci-moja-firma.csv&quot;) ## Parsed with column specification: ## cols( ## vraboten = col_character(), ## tip_na_trosok = col_character(), ## cena = col_double() ## ) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;)%&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;data/trosoci-moja-firma-sumirani.csv&quot;) Што се однесува до втората задача, имаме повеќе можности. Можеме да побараме корисникот да ја зачува патеката во варијабла која ќе биде користена од понатамошниот код. Ова сеуште дозволува патеки во друг директориум, и очигледно бара соодветна интервенција од корисникот, но ако ништо друго, корисникот на овој код, доколку ја прочита документацијата, може барем да ја повтори анализата без да добие грешки: # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # ВНИМАНИЕ: # Скриптата нема да работи доколку не внесете валидни дестинации # за фајлови за вчитување и зачувување pateka_do_input &lt;- NULL # &quot;data/trosoci-moja-firma.csv&quot; pateka_za_output &lt;- NULL # &quot;data/trosoci-moja-firma-sumirani.csv&quot; # На пример: # pateka_do_input &lt;- &quot;~/Downloads/trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;~/Downloads/trosoci-moja-firma-sumirani.csv&quot; # или: # pateka_do_input &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma-sumirani.csv&quot; # Вчитај ги податоците trosoci &lt;- read_csv(pateka_do_input) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = pateka_za_output) 5.3 Функција Алтернатива која бара малку поголема подготовка е да го напишеме функција која ќе работи на ист начин, земајќи ги патеките како аргументи: sumiraj_trosoci &lt;- function(trosoci, destinacija) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Често, сакаме табелата која ја снимаме да го има истото основно име како табелата што ја трансформираме (на пример moja-tabela.csv и moja-tabela-medijani.csv) и да се наоѓа во истиот фолдер. Со малку манипулација на текст во R (ова е уште полесно во Python) добиваме: # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Целата скрипта по овие промени би изгледала вака: # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Што сме постигнале до сега? Зависностите на кодот се решени. Документација имаме, впрочем, пишување на коментари во кодот треба да стане навика. И имаме функција на која може да и дадеме табела која што се наоѓа било каде и да зачуваме сумирана табела во истиот фолдер. 5.4 Rscript што може да го користиме без да отвараме R TODO: (for windows see: https://stackoverflow.com/questions/3506007/running-r-code-from-command-line-windows) Нашиот код е далеку подобар и има повеќе шанси да работи на други компјутери, но сеуште може да се каже дека има некои недостатоци. На пример, корисникот мора да отвори R, да ја вчита скриптата, и да ја изврши функцијата. Тоа е можеби во ред доколку нашиот колега има доволно познавање од R, но можеби нашиот шеф не знае R или едноставно нема време за чепкање во R терминал. Можеби сака решение од една линија: Rscript sumiraj_trosoci.R trosoci_dekemvri_2020.csv Да го конвертираме нашиот код во ваква скрипта е лесно. Прво, треба да специфицираме кој интерпретер треба да се користи за оваа скрипта со линијата #! /usr/bin/Rscript. Понатаму, треба само да го земеме името на фајлот даден по името на скриптата, и да го предадеме на нашата функција: #! /usr/bin/Rscript # (data/sumiraj-trosoci-2.R) # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент dadeni_trosoci &lt;- commandArgs(trailingOnly = TRUE)[[1]] # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Доколку го тестирате кодот додека читате го имате преземено директориумот за овој текст, оваа скрипта и податоците за трошоци се наоѓаат како фолдерот data под името /sumiraj-trosoci-1.R и trosoci-moja-firma.csv. Доколку сакаме навистина да се потрудиме, како поради безбедност така и поради лесно користење на ваквата скрипта, можеме да додадеме информации за користење на оваа скрипта, како и за проверка на аргументите. За да направиме упатство за користење, ќе го користиме пакетот docopt кој што користи таканаречен docstring, односно текст кој следи некои правила за форматирање со цел да биде лесно парсиран како прирачник за употреба на нашата скрипта. docopt/docstring имаат еквиваленти во сите други програмски јазици, така да доколку програмирате во Python или Perl веројатно ви се веќе познати овие концепти. За да провериме дека се е во ред со табелата што и е дадена на скриптата, ќе го користиме пакетот assertthat, што ни овозможува лесни проверки и информативни пораки за грешката. Стриктно гледано, пакетите docopt и assertthat не се неопходни, можеме да користиме функции како commandArgs() и stopifnot() од основната дистрибуција на R. Но во некои случаи користење на додатни пакети навистина ја олеснува работата. #! /usr/bin/Rscript # (data/sumiraj-trosoci-2.R) &#39;Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; &#39; -&gt; doc # Логика за аргументи library(docopt) arguments &lt;- docopt(doc) # Провери дали табелата е csv формат assertthat::assert_that(assertthat::has_extension(arguments$tabela_so_trosoci, ext = &quot;csv&quot;)) # Закачи ги ти пакетите кои се користат подолу suppressPackageStartupMessages({ library(dplyr) library(readr) library(assertthat) }) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # install.packages(assertthat) # Функција за групирање и сумирање трошоци # Аргументот `trosoci_tabela` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) assertthat::assert_that( inherits(trosoci, &quot;data.frame&quot;), msg = &quot;Табелата не беше вчитана како `data.frame`.&quot;) assertthat::assert_that( all(c(&quot;vraboten&quot;, &quot;tip_na_trosok&quot;, &quot;cena&quot;) %in% names(trosoci)), msg = &quot;Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;.&quot;) assertthat::assert_that( is.numeric(trosoci$cena), msg = &quot;Колоната `cena` мора да биде нумеричка.&quot;) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент (табелата) dadeni_trosoci &lt;- arguments$tabela_so_trosoci # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Со овие додатоци, нашата скрипта сега ќе може дури и да им помогне на корисниците доколку наидат на грешка. Сеуште не сме комплетно безбедни од не-репродуцибилност, но стигнавме далеку имајќи во предвид каде почнавме. На пример: # без аргументи $ Rscript sumiraj-trosoci-2.R Error: Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; Execution halted # со коректен инпут Rscript sumiraj-trosoci-2 trosoci-moja-firma.csv $ Rscript sumiraj-trosoci-2.R trosoci-moja-firma.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), cena = col_double() ) # со погрешен фајл Rscript sumiraj-trosoci-2 trosoci-moja-firma.xls Rscript sumiraj-trosoci-2.R trosoci-moja-firma.xls Error: File &#39;trosoci-moja-firma.xls&#39; does not have extension csv Execution halted # ако немаме колона за `cena`, таа е крстена `eur` Rscript sumiraj-trosoci-2 trosoci-moja-firma-eur.csv Rscript sumiraj-trosoci-2.R trosoci-moja-firma-eur.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), eur = col_double() ) Error: Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;. Execution halted "],["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],["references.html", "References", " References "]]
